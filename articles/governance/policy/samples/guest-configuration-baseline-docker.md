---
title: Reference - Azure Policy guest configuration baseline for Docker
description: Details of the Docker baseline on Azure implemented through Azure Policy guest configuration.
ms.date: 05/17/2022
ms.topic: reference
ms.custom: generated
---
# Docker security baseline

This article details the configuration settings for Docker hosts as applicable in the following
implementations:

- **\[Preview\]: Linux machines should meet requirements for the Azure security baseline for Docker hosts**
- **Vulnerabilities in security configuration on your machines should be remediated** in Azure
  Security Center

For more information, see [Understand the guest configuration feature of Azure Policy](../concepts/guest-configuration.md) and
[Overview of the Azure Security Benchmark (V2)](../../../security/benchmarks/overview.md).

## General security controls

|Name<br /><sub>(CCEID)</sub> |Details |Remediation check |
|---|---|---|
|Docker inventory Information<br /><sub>(0.0)</sub> |Description: None |None |
|Ensure a separate partition for containers has been created<br /><sub>(1.01)</sub> |Description: Docker depends on `/var/lib/docker` as the default directory where all Docker related files, including the images, are stored. This directory might fill up fast and soon Docker and the host could become unusable. So, it is advisable to create a separate partition (logical volume) for storing Docker files. |For new installations, create a separate partition for `/var/lib/docker` mount point. For systems that were previously installed, use the Logical Volume Manager (LVM) to create partitions. |
|Ensure docker version is up-to-date<br /><sub>(1.03)</sub> |Description: Using up-to-date docker version will keep your host secure |Follow the docker documentation in aim to upgrade your version |
|Ensure auditing is configured for the docker daemon<br /><sub>(1.05)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit Docker daemon as well. Docker daemon runs with root privileges. It is thus necessary to audit its activities and usage. |Add the line '-w /usr/bin/docker -k docker' into the /etc/audit/audit.rules file. Then, restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - /var/lib/docker<br /><sub>(1.06)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. /var/lib/docker is one such directory. It holds all the information about containers. It must be audited. |Add the line '-w /var/lib/docker -k docker' into the /etc/audit/audit.rules file. Then, restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - /etc/docker<br /><sub>(1.07)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. /etc/docker is one such directory. It holds various certificates and keys used for TLS communication between Docker daemon and Docker client. It must be audited. |Add the line '-w /etc/docker -k docker' into the /etc/audit/audit.rules file. Then, restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - docker.service<br /><sub>(1.08)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. docker.service is one such file. The docker.service file might be present if the daemon parameters have been changed by an administrator. It holds various parameters for Docker daemon. It must be audited, if applicable. |Find out the 'docker.service' file location by running: 'systemctl show -p FragmentPath docker.service' and add the line '-w {docker.service file location} -k docker' into the /etc/audit/audit.rules file where {docker.service file location} is the file path you have found earlier. Restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - docker.socket<br /><sub>(1.09)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. docker.socket is one such file. It holds various parameters for Docker daemon socket. It must be audited, if applicable. |Find out the 'docker.socket' file location by running: 'systemctl show -p FragmentPath docker.socket' and add the line '-w {docker.socket file location} -k docker' into the /etc/audit/audit.rules file where {docker.socket file location} is the file path you have found earlier. Restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - /etc/default/docker<br /><sub>(1.10)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. /etc/default/docker is one such file. It holds various parameters for Docker daemon. It must be audited, if applicable. |Add the line '-w /etc/default/docker -k docker' into the /etc/audit/audit.rules file. Then, restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - /etc/docker/daemon.json<br /><sub>(1.11)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. /etc/docker/daemon.json is one such file. It holds various parameters for Docker daemon. It must be audited, if applicable. |Add the line '-w /etc/docker/daemon.json -k docker' into the /etc/audit/audit.rules file. Then, restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - /usr/bin/docker-containerd<br /><sub>(1.12)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. /usr/bin/docker-containerd is one such file. Docker now relies on containerdand runC to spawn containers. It must be audited, if applicable. |Add the line '-w /usr/bin/docker-containerd -k docker' into the /etc/audit/audit.rules file. Then, restart the audit daemon by running the command: 'service auditd restart' |
|Ensure auditing is configured for Docker files and directories - /usr/bin/docker-runc<br /><sub>(1.13)</sub> |Description: Apart from auditing your regular Linux file system and system calls, audit all Docker related files and directories. Docker daemon runs with root privileges. Its behavior depends on some key files and directories. /usr/bin/docker-runc is one such file. Docker now relies on containerd and runC to spawn containers. It must be audited, if applicable. |Add the line '-w /usr/bin/docker-runc -k docker' into the /etc/audit/audit.rules file. Then, restart the audit daemon by running the command: 'service auditd restart' |
|Ensure network traffic is restricted between containers on the default bridge<br /><sub>(2.01)</sub> |Description: The inter-container communication would be disabled on the default network bridge. If any communication between containers on the same host is desired, then it needs to be explicitly defined using container linking or alternatively custom networks have to be defined. |Run the docker in daemon mode and pass --icc=false as an argument or set the 'icc' setting to false in the daemon.json file. Alternatively, you can follow the Docker documentation and create a custom network and only join containers that need to communicate to that custom network. The --icc parameter only applies to the default docker bridge, if custom networks are used then the approach of segmenting networks should be adopted instead. |
|Ensure the logging level is set to 'info'.<br /><sub>(2.02)</sub> |Description: Setting up an appropriate log level, configures the Docker daemon to log events that you would want to review later. A base log level of `info` and above would capture all logs except debug logs. Until and unless required, you should not run Docker daemon at `debug` log level. |Run the Docker daemon as below:```dockerd --log-level info```|
|Ensure Docker is allowed to make changes to iptables<br /><sub>(2.03)</sub> |Description: Docker will never make changes to your system `iptables` rules if you choose to do so. Docker server would automatically make the needed changes to iptables based on how you choose your networking options for the containers if it is allowed to do so. It is recommended to let Docker server make changes to `iptables`automatically to avoid networking misconfiguration that might hamper the communication between containers and to the outside world. Additionally, it would save you hassles of updating `iptable`every time you choose to run the containers or modify networking options. |Do not run the Docker daemon with `--iptables=false` parameter. For example, do not start the Docker daemon as below:```dockerd --iptables=false```|
|Ensure insecure registries are not used<br /><sub>(2.04)</sub> |Description: You should not be using any insecure registries in the production environment. Insecure registries can be tampered with leading to possible compromise to your production system. |remove '--insecure-registry' flag from the dockerd start command |
|The 'aufs' storage driver should not be used by the docker daemon<br /><sub>(2.05)</sub> |Description: The 'aufs' storage driver is the oldest storage driver. It is based on a Linux kernel patch-set that is unlikely to be merged into the main Linux kernel. aufs driver is also known to cause some serious kernel crashes. aufs just has legacy support from Docker. Most importantly, aufs is not a supported driver in many Linux distributions using latest Linux kernels |The 'aufs' storage driver should be replaced by a different storage driver, we recommend to use 'overlay2' |
|Ensure TLS authentication for Docker daemon is configured<br /><sub>(2.06)</sub> |Description: By default, Docker daemon binds to a non-networked Unix socket and runs with `root` privileges. If you change the default docker daemon binding to a TCP port or any other Unix socket, anyone with access to that port or socket can have full access to Docker daemon and in turn to the host system. Hence, you should not bind the Docker daemon to another IP/port or a Unix socket. If you must expose the Docker daemon via a network socket, configure TLS authentication for the daemon and Docker Swarm APIs (if using). This would restrict the connections to your Docker daemon over the network to a limited number of clients who could successfully authenticate over TLS. |Follow the steps mentioned in the Docker documentation or other references. |
|Ensure the default ulimit is configured appropriately<br /><sub>(2.07)</sub> |Description: If the ulimits are not set properly, the desired resource control might not be achieved and might even make the system unusable. |Run the docker in daemon mode and pass --default-ulimit as argument with respective ulimits as appropriate in your environment. Alternatively, you can also set a specific resource limitation to each container separately by using the --ulimit argument with respective ulimits as appropriate in your environment. |
|Enable user namespace support<br /><sub>(2.08)</sub> |Description: The Linux kernel user namespace support in Docker daemon provides additional security for the Docker host system. It allows a container to have a unique range of user and group IDs which are outside the traditional user and group range utilized by the host system. For example, the root user will have expected administrative privilege inside the container but can effectively be mapped to an unprivileged UID on the host system. |Please consult Docker documentation for various ways in which this can be configured depending upon your requirements. Your steps might also vary based on platform - For example, on Red Hat, sub-UIDs and sub-GIDs mapping creation does not work automatically. You might have to create your own mapping. However, the high-level steps are as below: **Step 1:** Ensure that the files `/etc/subuid` and `/etc/subgid` exist.```touch /etc/subuid /etc/subgid```**Step 2:** Start the docker daemon with `--userns-remap` flag```dockerd --userns-remap=default```|
|Ensure base device size is not changed until needed<br /><sub>(2.10)</sub> |Description: Increasing the base device size allows all future images and containers to be of the new base device size, This may cause a denial of service by ending up in file system being over-allocated or full. |remove '--storage-opt dm.basesize' flag from the dockerd start command until you need it |
|Ensure that authorization for Docker client commands is enabled<br /><sub>(2.11)</sub> |Description: Docker’s out-of-the-box authorization model is all or nothing. Any user with permission to access the Docker daemon can run any Docker client command. The same is true for callers using Docker’s remote API to contact the daemon. If you require greater access control, you can create authorization plugins and add them to your Docker daemon configuration. Using an authorization plugin, a Docker administrator can configure granular access policies for managing access to Docker daemon. Third party integrations of Docker may implement their own authorization models to require authorization with the Docker daemon outside of docker's native authorization plugin (i.e. Kubernetes, Cloud Foundry, Openshift). |**Step 1**: Install/Create an authorization plugin. **Step 2**: Configure the authorization policy as desired. **Step 3**: Start the docker daemon as below:```dockerd --authorization-plugin=```|
|Ensure centralized and remote logging is configured<br /><sub>(2.12)</sub> |Description: Centralized and remote logging ensures that all important log records are safe despite catastrophic events. Docker now supports various such logging drivers. Use the one that suits your environment the best. |**Step 1**: Setup the desired log driver by following its documentation. **Step 2**: Start the docker daemon with that logging driver. For example,```dockerd --log-driver=syslog --log-opt syslog-address=tcp://192.xxx.xxx.xxx```|
|Ensure live restore is Enabled<br /><sub>(2.14)</sub> |Description: One of the important security triads is availability. Setting `--live-restore` flag in the docker daemon ensures that container execution is not interrupted when the docker daemon is not available. This also means that it is now easier to update and patch the docker daemon without execution downtime. |Run the docker in daemon mode and pass `--live-restore` as an argument. For Example,```dockerd --live-restore```|
|Ensure Userland Proxy is Disabled<br /><sub>(2.15)</sub> |Description: Docker engine provides two mechanisms for forwarding ports from the host to containers, hairpin NAT, and a userland proxy. In most circumstances, the hairpin NAT mode is preferred as it improves performance and makes use of native Linux iptables functionality instead of an additional component. Where hairpin NAT is available, the userland proxy should be disabled on startup to reduce the attack surface of the installation. |Run the Docker daemon as below:```dockerd --userland-proxy=false```|
|Ensure experimental features are avoided in production<br /><sub>(2.17)</sub> |Description: Experimental is now a runtime docker daemon flag instead of a separate build. Passing `--experimental` as a runtime flag to the docker daemon, activates experimental features. Experimental is now considered a stable release, but with a couple of features which might not have tested and guaranteed API stability. |Do not pass `--experimental` as a runtime parameter to the docker daemon. |
|Ensure containers are restricted from acquiring new privileges.<br /><sub>(2.18)</sub> |Description: A process can set the `no_new_priv` bit in the kernel. It persists across fork, clone and execve. The `no_new_priv` bit ensures that the process or its children processes do not gain any additional privileges via suid or sgid bits. This way a lot of dangerous operations become a lot less dangerous because there is no possibility of subverting privileged binaries. Setting this at the daemon level ensures that by default all new containers are restricted from acquiring new privileges. |Run the Docker daemon as below:```dockerd --no-new-privileges```|
|Ensure that docker.service file ownership is set to root:root.<br /><sub>(3.01)</sub> |Description: `docker.service` file contains sensitive parameters that may alter the behavior of Docker daemon. Hence, it should be owned and group-owned by `root` to maintain the integrity of the file. |**Step 1**: Find out the file location:```systemctl show -p FragmentPath docker.service```**Step 2**: If the file does not exist, this recommendation is not applicable. If the file exists, execute the below command with the correct file path to set the ownership and group ownership for the file to `root`. For example,```chown root:root /usr/lib/systemd/system/docker.service```|
|Ensure that docker .service file permissions are set to 644 or more restrictive<br /><sub>(3.02)</sub> |Description: `docker.service` file contains sensitive parameters that may alter the behavior of Docker daemon. Hence, it should not be writable by any other user other than `root` to maintain the integrity of the file. |**Step 1**: Find out the file location:```systemctl show -p FragmentPath docker.service```**Step 2**: If the file does not exist, this recommendation is not applicable. If the file exists, execute the below command with the correct file path to set the file permissions to `644`. For example,```chmod 644 /usr/lib/systemd/system/docker.service```|
|Ensure that docker.socket file ownership is set to root:root.<br /><sub>(3.03)</sub> |Description: `docker.socket` file contains sensitive parameters that may alter the behavior of Docker remote API. Hence, it should be owned and group-owned by `root` to maintain the integrity of the file. |**Step 1**: Find out the file location:```systemctl show -p FragmentPath docker.socket```**Step 2**: If the file does not exist, this recommendation is not applicable. If the file exists, execute the below command with the correct file path to set the ownership and group ownership for the file to `root`. For example,```chown root:root /usr/lib/systemd/system/docker.socket```|
|Ensure that docker.socket file permissions are set to 644 or more restrictive<br /><sub>(3.04)</sub> |Description: `docker.socket` file contains sensitive parameters that may alter the behavior of Docker daemon. Hence, it should not be writable by any other user other than `root` to maintain the integrity of the file. |**Step 1**: Find out the file location:```systemctl show -p FragmentPath docker.socket```**Step 2**: If the file does not exist, this recommendation is not applicable. If the file exists, execute the below command with the correct file path to set the file permissions to `644`. For example,```chmod 644 /usr/lib/systemd/system/docker.service```|
|Ensure that /etc/docker directory owership is set to root:root.<br /><sub>(3.05)</sub> |Description: `/etc/docker` directory contains certificates and keys in addition to various sensitive files. Hence, it should be owned and group-owned by `root` to maintain the integrity of the directory. |```chown root:root /etc/docker```This would set the ownership and group-ownership for the directory to `root`. |
|Ensure that /etc/docker directory permissions are set to 755 or more restrictive<br /><sub>(3.06)</sub> |Description: `/etc/docker` directory contains certificates and keys in addition to various sensitive files. Hence, it should only be writable by `root` to maintain the integrity of the directory. |```chmod 755 /etc/docker```This would set the permissions for the directory to `755`. |
|Ensure that registry certificate file ownership is set to root:root<br /><sub>(3.07)</sub> |Description: `/etc/docker/certs.d/` directory contains Docker registry certificates. These certificate files must be owned and group-owned by `root` to maintain the integrity of the certificates. |```chown root:root /etc/docker/certs.d//*```This would set the ownership and group-ownership for the registry certificate files to `root`. |
|Ensure that registry certificate file permissions are set to 444 or more restrictive<br /><sub>(3.08)</sub> |Description: `/etc/docker/certs.d/` directory contains Docker registry certificates. These certificate files must have permissions of `444` to maintain the integrity of the certificates. |```chmod 444 /etc/docker/certs.d//*```This would set the permissions for registry certificate files to `444`. |
|Ensure that TLS CA certificate file ownersip is set to root:root<br /><sub>(3.09)</sub> |Description: The TLS CA certificate file should be protected from any tampering. It is used to authenticate Docker server based on given CA certificate. Hence, it must be owned and group-owned by `root` to maintain the integrity of the CA certificate. |```chown root:root```This would set the ownership and group-ownership for the TLS CA certificate file to `root`. |
|Ensure that TLS CA certificate file permissions are set to 444 or more restrictive<br /><sub>(3.10)</sub> |Description: The TLS CA certificate file should be protected from any tampering. It is used to authenticate Docker server based on given CA certificate. Hence, it must have permissions of `444` to maintain the integrity of the CA certificate. |```chmod 444```This would set the file permissions of the TLS CA file to `444`. |
|Ensure that Docker server certificate file ownership is set to root:root<br /><sub>(3.11)</sub> |Description: The Docker server certificate file should be protected from any tampering. It is used to authenticate Docker server based on the given server certificate. Hence, it must be owned and group-owned by `root` to maintain the integrity of the certificate. |```chown root:root```This would set the ownership and group-ownership for the Docker server certificate file to `root`. |
|Ensure that Docker server certificate file permissions are set to 444 or more restrictive<br /><sub>(3.12)</sub> |Description: The Docker server certificate file should be protected from any tampering. It is used to authenticate Docker server based on the given server certificate. Hence, it must have permissions of `444` to maintain the integrity of the certificate. |```chmod 444```This would set the file permissions of the Docker server file to `444`. |
|Ensure that Docker server certificate key file ownership is set to root:root<br /><sub>(3.13)</sub> |Description: The Docker server certificate key file should be protected from any tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence, it must be owned and group-owned by `root` to maintain the integrity of the Docker server certificate. |```chown root:root```This would set the ownership and group-ownership for the Docker server certificate key file to `root`. |
|Ensure that Docker server certificate key file permissions are set to 400<br /><sub>(3.14)</sub> |Description: The Docker server certificate key file should be protected from any tampering or unneeded reads. It holds the private key for the Docker server certificate. Hence, it must have permissions of `400` to maintain the integrity of the Docker server certificate. |```chmod 400```This would set the Docker server certificate key file permissions to `400`. |
|Ensure that Docker socket file ownership is set to root:docker<br /><sub>(3.15)</sub> |Description: Docker daemon runs as `root`. The default Unix socket hence must be owned by `root`. If any other user or process owns this socket, then it might be possible for that non-privileged user or process to interact with Docker daemon. Also, such a non-privileged user or process might interact with containers. This is neither secure nor desired behavior. Additionally, the Docker installer creates a Unix group called `docker`. You can add users to this group, and then those users would be able to read and write to default Docker Unix socket. The membership to the `docker` group is tightly controlled by the system administrator. If any other group owns this socket, then it might be possible for members of that group to interact with Docker daemon. Also, such a group might not be as tightly controlled as the `docker` group. This is neither secure nor desired behavior. Hence, the default Docker Unix socket file must be owned by `root` and group-owned by `docker` to maintain the integrity of the socket file. |```chown root:docker /var/run/docker.sock```This would set the ownership to `root` and group-ownership to `docker` for default Docker socket file. |
|Ensure that Docker socket file permissions are set to 660 or more restrictive<br /><sub>(3.16)</sub> |Description: Only `root` and members of `docker` group should be allowed to read and write to default Docker Unix socket. Hence, the Docket socket file must have permissions of `660` or more restrictive. |```chmod 660 /var/run/docker.sock```This would set the file permissions of the Docker socket file to `660`. |
|Ensure that daemon.json file ownership is set to root:root<br /><sub>(3.17)</sub> |Description: `daemon.json` file contains sensitive parameters that may alter the behavior of docker daemon. Hence, it should be owned and group-owned by `root` to maintain the integrity of the file. |```chown root:root /etc/docker/daemon.json```This would set the ownership and group-ownership for the file to `root`. |
|Ensure that daemon.json file permissions are set to 644 or more restrictive<br /><sub>(3.18)</sub> |Description: `daemon.json` file contains sensitive parameters that may alter the behavior of docker daemon. Hence, it should be writable only by `root` to maintain the integrity of the file. |```chmod 644 /etc/docker/daemon.json```This would set the file permissions for this file to `644`. |
|Ensure that /etc/default/docker file ownership is set to root:root<br /><sub>(3.19)</sub> |Description: `/etc/default/docker` file contains sensitive parameters that may alter the behavior of docker daemon. Hence, it should be owned and group-owned by `root` to maintain the integrity of the file. |```chown root:root /etc/default/docker```This would set the ownership and group-ownership for the file to `root`. |
|Ensure that /etc/default/docker file permissions are set to 644 or more restrictive<br /><sub>(3.20)</sub> |Description: `/etc/default/docker` file contains sensitive parameters that may alter the behavior of docker daemon. Hence, it should be writable only by `root` to maintain the integrity of the file. |```chmod 644 /etc/default/docker```This would set the file permissions for this file to `644`. |
|Ensure a user for the container has been created<br /><sub>(4.01)</sub> |Description: It is a good practice to run the container as a non-root user, if possible. Though user namespace mapping is now available, if a user is already defined in the container image, the container is run as that user by default and specific user namespace remapping is not required. |Ensure that the Dockerfile for the container image contains: 'USER {username or ID}' where username or ID refers to the user that could be found in the container base image. If there is no specific user created in the container base image, then add a useradd command to add the specific user before USER instruction. |
|Ensure HEALTHCHECK instructions have been added to the container image<br /><sub>(4.06)</sub> |Description: One of the important security triads is availability. Adding `HEALTHCHECK` instruction to your container image ensures that the docker engine periodically checks the running container instances against that instruction to ensure that the instances are still working. Based on the reported health status, the docker engine could then exit non-working containers and instantiate new ones. |Follow Docker documentation and rebuild your container image with `HEALTHCHECK` instruction. |
|Ensure either SELinux or AppArmor is enabled as appropriate<br /><sub>(5.01-2)</sub> |Description: AppArmor protects the Linux OS and applications from various threats by enforcing security policy which is also known as AppArmor profile. You can create your own AppArmor profile for containers or use the Docker's default AppArmor profile. This would enforce security policies on the containers as defined in the profile. SELinux provides a Mandatory Access Control (MAC) system that greatly augments the default Discretionary Access Control (DAC) model. You can thus add an extra layer of safety by enabling SELinux on your Linux host, if applicable. |After enabling the relevent Mandatory Access Control Plugin for your distro, run the docker daemon as```docker run --interactive --tty --security-opt="apparmor:PROFILENAME" centos /bin/bash```for AppArmor or```docker run --interactive --tty --security-opt label=level:TopSecret centos /bin/bash for SELinux. |
|Ensure Linux Kernel Capabilities are restricted within containers<br /><sub>(5.03)</sub> |Description: Docker supports the addition and removal of capabilities, allowing the use of a non-default profile. This may make Docker more secure through capability removal, or less secure through the addition of capabilities. It is thus recommended to remove all capabilities except those explicitly required for your container process. For example, capabilities such as below are usually not needed for container process:```NET_ADMIN SYS_ADMIN SYS_MODULE```|Execute the below command to add needed capabilities: $> docker run --cap-add={"Capability 1","Capability 2"}    For example,```docker run --interactive --tty --cap-add={"NET_ADMIN","SYS_ADMIN"} centos:latest /bin/bash```Execute the below command to drop unneeded capabilities: $> docker run --cap-drop={"Capability 1","Capability 2"}    For example,```docker run --interactive --tty --cap-drop={"SETUID","SETGID"} centos:latest /bin/bash```Alternatively, You may choose to drop all capabilities and add only add the needed ones: $> docker run --cap-drop=all --cap-add={"Capability 1","Capability 2"}    For example,```docker run --interactive --tty --cap-drop=all --cap-add={"NET_ADMIN","SYS_ADMIN"} centos:latest /bin/bash```|
|Ensure privileged containers are not used<br /><sub>(5.04)</sub> |Description: The `--privileged` flag gives all capabilities to the container, and it also lifts all the limitations enforced by the device cgroup controller. In other words, the container can then do almost everything that the host can do. This flag exists to allow special use-cases, like running Docker within Docker. |Do not run container with the `--privileged` flag. For example, do not start a container as below:```docker run --interactive --tty --privileged centos /bin/bash```|
|Ensure sensitive host system directories are not mounted on containers<br /><sub>(5.05)</sub> |Description: If sensitive directories are mounted in read-write mode, it would be possible to make changes to files within those sensitive directories. The changes might bring down security implications or unwarranted changes that could put the Docker host in compromised state. |Do not mount host sensitive directories on containers especially in read-write mode. |
|Ensure the host's network namespace is not shared<br /><sub>(5.09)</sub> |Description: This is potentially dangerous. It allows the container process to open low-numbered ports like any other `root` process. It also allows the container to access network services like D-bus on the Docker host. Thus, a container process can potentially do unexpected things such as shutting down the Docker host. You should not use this option. |Do not pass `--net=host` option when starting the container. |
|Ensure memory usage for container is limited<br /><sub>(5.10)</sub> |Description: By default, container can use all of the memory on the host. You can use memory limit mechanism to prevent a denial of service arising from one container consuming all of the host’s resources such that other containers on the same host cannot perform their intended functions. Having no limit on memory can lead to issues where one container can easily make the whole system unstable and as a result unusable. |Run the container with only as much memory as required. Always run the container using the `--memory` argument. For example, you could run a container as below:```docker run --interactive --tty --memory 256m centos /bin/bash```In the above example, the container is started with a memory limit of 256 MB. Note: Please note that the output of the below command would return values in scientific notation if memory limits are in place.```docker inspect --format='{{.Config.Memory}}' 7c5a2d4c7fe0```For example, if the memory limit is set to `256 MB` for the above container instance, the output of the above command would be `2.68435456e+08` and NOT 256m. You should convert this value using a scientific calculator or programmatic methods. |
|Ensure the container's root filesystem is mounted as read only<br /><sub>(5.12)</sub> |Description: Enabling this option forces containers at runtime to explicitly define their data writing strategy to persist or not persist their data. This also reduces security attack vectors since the container instance's filesystem cannot be tampered with or written to unless it has explicit read-write permissions on its filesystem folder and directories. |Add a `--read-only` flag at a container's runtime to enforce the container's root filesystem to be mounted as read only.```docker run  --read-only```Enabling the `--read-only` option at a container's runtime should be used by administrators to force a container's executable processes to only write container data to explicit storage locations during the container's runtime. Examples of explicit storage locations during a container's runtime include, but not limited to: 1. Use the `--tmpfs` option to mount a temporary file system for non-persistent data writes.```docker run --interactive --tty --read-only --tmpfs "/run" --tmpfs "/tmp" centos /bin/bash```2. Enabling Docker `rw` mounts at a container's runtime to persist container data directly on the Docker host filesystem.```docker run --interactive --tty --read-only -v /opt/app/data:/run/app/data:rw centos /bin/bash```3. Utilizing Docker shared-storage volume plugins for Docker data volume to persist container data.```docker volume create -d convoy --opt o=size=20GB my-named-volume``````docker run --interactive --tty --read-only -v my-named-volume:/run/app/data centos /bin/bash```3. Transmitting container data outside of the docker during the container's runtime for container data to persist container data. Examples include hosted databases, network file shares, and APIs. |

> [!NOTE]
> Availability of specific Azure Policy guest configuration settings may vary in Azure Government
> and other national clouds.

## Next steps

Additional articles about Azure Policy and guest configuration:

- [Understand the guest configuration feature of Azure Policy]Understand the guest configuration feature of Azure Polic(../concepts/guest-configuration.md).
- [Regulatory Compliance](../concepts/regulatory-compliance.md) overview.
- Review other examples at [Azure Policy samples](./index.md).
- Review [Understanding policy effects](../concepts/effects.md).
- Learn how to [remediate non-compliant resources](../how-to/remediate-resources.md).
